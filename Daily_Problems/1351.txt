âœ… Layman Documentation for the O(m + n) Solution
ğŸ” Goal

Count how many negative numbers are present in a matrix where:

Each row is sorted from largest to smallest.

Each column is also sorted from top to bottom in non-increasing order.

Example of sorted order:

 4  3  2 -1
 3  2  1 -1
 1  1 -1 -2
-1 -1 -2 -3

ğŸ“˜ How the algorithm works (in simple words)

We use a smart scanning technique instead of checking every element.

ğŸ¯ Key idea

Start from the top-right corner of the matrix.

Why?

Because from this position:

Moving left goes to smaller numbers.

Moving down goes to smaller numbers.

This helps us skip large chunks at once.

ğŸ‘£ Step-by-step explanation
âœ¨ Start at top-right

row = 0
col = n - 1 (last column)

ğŸ¤” At each step:

If the number is negative:

All numbers below in the same column are ALSO negative
(because the column is sorted in non-increasing order).

So we add (m - row) negatives at once to the count.

Then move left to check smaller numbers.

If the number is NOT negative:

Move down, because below values might be negative.

This continues until:

We move outside the left boundary (col < 0)
OR

We move past the bottom row (row == m)

ğŸ“„ Full documented code (layman-friendly)
class Solution {
    public int countNegatives(int[][] grid) {

        // m = total rows, n = total columns
        int m = grid.length;
        int n = grid[0].length;

        // Start at top-right: (0, n-1)
        int row = 0;
        int col = n - 1;

        int count = 0;

        // Continue while inside the matrix boundaries
        while (row < m && col >= 0) {

            // If current value is negative
            if (grid[row][col] < 0) {

                // All elements below this (in the same column) must also be negative,
                // because the column is sorted in decreasing order.
                count += (m - row);

                // Move left to check the next number
                col--;

            } else {

                // If not negative, move down to find smaller numbers
                row++;
            }
        }

        // Total negative numbers found
        return count;
    }
}

ğŸ§  Why this is fast

We only move left or down, never backtracking.

Max moves = m + n
â†’ O(m + n) time.

Much faster than checking every cell (O(m Ã— n)).