âœ… Intuition (Layman Explanation)

You have two sorted arrays:

nums1 â†’ has extra empty space (0s) at the end

nums2 â†’ smaller sorted array

Example:

nums1 = [1,2,3,0,0,0]
nums2 = [2,5,6]


You must merge nums2 into nums1 so that nums1 becomes:

[1,2,2,3,5,6]


But you cannot use extra array â€” the result must be stored inside nums1 itself.

ğŸš€ Key Idea (Optimal O(m + n))
ğŸ‘‰ Start merging from the end of nums1

Because:

The end of nums1 has empty space

If you start inserting from the front, you will overwrite useful elements

So we place the largest remaining element at the end.

We use 3 pointers:

Pointer	Meaning
i = m-1	Last real element of nums1
j = n-1	Last element of nums2
k = m+n-1	Last index of nums1 (final position)

public void merge(int[] nums1, int m, int[] nums2, int n) {
    int i = m - 1;       // pointer for nums1
    int j = n - 1;       // pointer for nums2
    int k = m + n - 1;   // pointer for placement in nums1

    // While both arrays have elements
    while (i >= 0 && j >= 0) {
        if (nums1[i] > nums2[j]) {
            nums1[k] = nums1[i];
            i--;
        } else {
            nums1[k] = nums2[j];
            j--;
        }
        k--;
    }

    // If nums2 still has leftover elements
    while (j >= 0) {
        nums1[k] = nums2[j];
        j--;
        k--;
    }
}

Step-by-step meaning of code:
1ï¸âƒ£ Setup three pointers

i points to last valid element in nums1

j points to last element in nums2

k points to last position in nums1 (where merged result goes)

2ï¸âƒ£ Compare from the end

Pick the bigger element from nums1[i] or nums2[j] and put it at nums1[k].

This works because both arrays are already sorted.

3ï¸âƒ£ Move pointers backwards

After placing a value, move the corresponding pointer one step left.

4ï¸âƒ£ If nums2 has leftovers

Copy them to nums1:

Because nums1â€™s leftover elements are already in correct position.

ğŸ§  Example Walkthrough (Short)
nums1 = [1,2,3,0,0,0]
nums2 = [2,5,6]

i = 2 (3)
j = 2 (6)
k = 5


Compare 3 and 6 â†’ 6 is bigger â†’ put 6 at end.

nums1 = [1,2,3,0,0,6]


Continue until all nums2 values are placed.

ğŸ‰ Final Result

The algorithm runs in:

O(m + n) time

O(1) extra space

Uses nums1 efficiently by filling from the back