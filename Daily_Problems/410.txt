LeetCode: Split Array Largest Sum (Minimize the Maximum)
âœ… Problem Summary (in 1 line)

Split nums into exactly k non-empty contiguous subarrays such that the largest subarray sum is minimized, and return that minimum value.

ğŸ§  Brain Note (3 lines)

Pattern: Binary Search on Answer (Minimize Maximum)

When to use: â€œSplit into k partsâ€ + â€œminimize the largest / worstâ€

Core idea: Guess max allowed sum X, greedily split â†’ check if possible in â‰¤ k parts

âœ… Observations
What are we minimizing?

We are minimizing:

max
â¡
(
sum of each subarray
)
max(sum of each subarray)

So we want the â€œworstâ€ subarray sum to be as small as possible.

Important bounds

Minimum possible answer = max(nums)

because some subarray must contain the biggest element

Maximum possible answer = sum(nums)

if we donâ€™t split at all (one big subarray)

So the answer lies in:

[
ğ‘š
ğ‘
ğ‘¥
(
ğ‘›
ğ‘¢
ğ‘š
ğ‘ 
)
,
â€…â€Š
ğ‘ 
ğ‘¢
ğ‘š
(
ğ‘›
ğ‘¢
ğ‘š
ğ‘ 
)
]
[max(nums),sum(nums)]
âœ… Key Trick: Binary Search on the Answer

We binary search on the value â€œlargest subarray sum allowedâ€.

Let mid = candidate max sum.

Now we ask:

âœ… Can we split nums into at most k subarrays so that each subarray sum â‰¤ mid?

If yes â†’ try smaller (move left)
If no â†’ need bigger (move right)

âœ… Greedy Feasibility Check (Most Important Part)
âœ… canSplit(nums, k, maxSum) logic

We greedily build subarrays:

Keep adding elements to current subarray sum

If adding next element makes sum > maxSum

start a new subarray

increase subarray count

If subarray count exceeds k, return false

Why greedy works?

Because to minimize number of subarrays, you should pack as many elements as possible into the current subarray before starting a new one.

âœ… Java Code (Final)
class Solution {
    public int splitArray(int[] nums, int k) {
        long left = 0, right = 0;

        // left = max(nums), right = sum(nums)
        for (int x : nums) {
            left = Math.max(left, x);
            right += x;
        }

        while (left < right) {
            long mid = left + (right - left) / 2;

            if (canSplit(nums, k, mid)) {
                right = mid;      // mid is possible â†’ try smaller
            } else {
                left = mid + 1;   // mid not possible â†’ increase
            }
        }

        return (int) left;
    }

    private boolean canSplit(int[] nums, int k, long maxSum) {
        int subarrays = 1;
        long currSum = 0;

        for (int x : nums) {
            if (currSum + x <= maxSum) {
                currSum += x;
            } else {
                subarrays++;
                currSum = x;

                if (subarrays > k) return false;
            }
        }

        return true;
    }
}

ğŸ§© Walkthrough Example (nums = [7,2,5,10,8], k = 2)
Bounds:

left = max(nums) = 10

right = sum(nums) = 32

Binary search mid values:

Try mid = 21

Greedy split:

[7,2,5] sum=14

add 10 â†’ 24 (too much) â†’ new subarray

[10,8] sum=18

Subarrays = 2 âœ… valid â†’ try smaller

Try mid = 18

Greedy split:

[7,2,5] sum=14

add 10 â†’ 24 (too much) â†’ new subarray

[10,8] sum=18

Subarrays = 2 âœ… valid â†’ try smaller

Try mid = 17

[7,2,5] sum=14

add 10 â†’ 24 too much â†’ new subarray

[10] sum=10

add 8 â†’ 18 too much â†’ new subarray

[8]

Subarrays = 3 âŒ not valid â†’ need bigger

âœ… Answer becomes 18

âœ… Why â‰¤ k subarrays works (important confusion!)

In feasibility check we ensure it can be done in at most k subarrays.

Because:

If we can split into fewer than k, we can always split more by breaking a subarray further (without increasing maxSum).

Example: if k=5 and we can do it in 3 subarrays, we can split some subarray into smaller ones.

So <= k means possible.

âœ… Complexity

canSplit() = O(n)

Binary search runs about log(sum(nums))
âœ… Total: O(n log(sum(nums)))

Space: O(1)

âœ… Common Mistakes (Quick Checklist)

âœ… Use long for sums (because sum(nums) can overflow int)
âœ… left = max element, not 0
âœ… Greedy split based on â€œif exceeds midâ€
âœ… Return left at the end (binary search converges)