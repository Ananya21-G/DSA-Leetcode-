LeetCode 154 â€” Find Minimum in Rotated Sorted Array II (Duplicates Allowed)
ğŸ§  Brain Note (3 lines)

Pattern: Binary Search on Rotated Sorted Array (with duplicates)
When to use: Rotated sorted array, need min/target efficiently, duplicates possible
Core idea: Compare mid with right; duplicates force right-- (worst-case O(n))

âœ… Problem Summary

Given a sorted array rotated between 1..n times with duplicates, return the minimum element.

Example:
[2,2,2,0,1] â†’ 0

ğŸ” Key Idea

Use binary search with pointers:

l = 0, r = n-1

compare nums[mid] with nums[r]

This helps identify whether mid lies in the left (higher) part or right (lower) part of the rotated array.

âœ… Decision Rules

Let mid = l + (r-l)/2

1) If nums[mid] > nums[r]

âœ… Minimum is in the right half
â¡ï¸ l = mid + 1

2) If nums[mid] < nums[r]

âœ… Minimum is in the left half (including mid)
â¡ï¸ r = mid

3) If nums[mid] == nums[r] (duplicates case)

âš ï¸ Cannot decide the side
â¡ï¸ r-- (safe shrink)

âœ… Java Code (Reference)
class Solution {
    public int findMin(int[] nums) {
        int l = 0, r = nums.length - 1;

        while (l < r) {
            int mid = l + (r - l) / 2;

            if (nums[mid] > nums[r]) {
                l = mid + 1;
            } else if (nums[mid] < nums[r]) {
                r = mid;
            } else {
                r--; // duplicates: can't decide, shrink safely
            }
        }

        return nums[l];
    }
}

â±ï¸ Time & Space Complexity

âœ… Best / typical: O(log n)
âš ï¸ Worst case: O(n) (when duplicates prevent halving, e.g. [1,1,1,1,1])
âœ… Space: O(1)

ğŸ¯ Why duplicates change runtime?

Because when nums[mid] == nums[r], we lose information, so we canâ€™t discard half confidently â€” we only do r--, which may take n steps.