925. Long Pressed Name
ğŸ”¹ Problem Statement (Simplified)

Your friend is typing their name on a keyboard.
Sometimes, a key is long-pressed, so a character may appear multiple times instead of once.

You are given:

name â†’ the intended string

typed â†’ the string that actually appeared

Task

Return true if typed can be formed from name by long-pressing some characters.
Otherwise, return false.

ğŸ”¹ Key Rules

Characters must appear in the same order

Characters in typed can repeat only if they match the previous character

You cannot skip characters from name

You cannot add new characters

ğŸ”¹ Examples
Example 1
name  = "alex"
typed = "aaleex"


Explanation:

'a' â†’ "aa" (long pressed)

'l' â†’ "l"

'e' â†’ "ee" (long pressed)

'x' â†’ "x"

âœ… Valid â†’ true

Example 2
name  = "saeed"
typed = "ssaaedd"


Explanation:

name needs two 'e'

typed has only one 'e'

âŒ Invalid â†’ false

ğŸ§  Brain Note (Memory Anchor)

Pattern: Two Pointers

When to use: Comparing two strings while allowing controlled repetition

Core idea: Extra characters are allowed only if they repeat the previous one

ğŸ”¹ Approach (Step-by-Step)

We compare both strings from left to right using two pointers.

Pointers

i â†’ index for name

j â†’ index for typed

At each step:

If characters match

name[i] == typed[j]


â†’ Move both pointers forward

If characters donâ€™t match

Check if typed[j] is a repeat of the previous typed character

typed[j] == typed[j - 1]


â†’ This means long press â†’ move only j

Otherwise

Invalid situation â†’ return false

Final Check

After the loop:

If all characters of name are used â†’ return true

Else â†’ return false

ğŸ”¹ Why This Approach Works

Maintains order

Allows controlled repetition

Prevents missing or extra characters

Runs in linear time

â±ï¸ Time & Space Complexity

Time Complexity: O(n)
(n = length of typed)

Space Complexity: O(1)
(no extra data structures)

ğŸ§‘â€ğŸ’» Java Solution (Well-Documented)
class Solution {
    public boolean isLongPressedName(String name, String typed) {

        int i = 0; // Pointer for name
        int j = 0; // Pointer for typed

        while (j < typed.length()) {

            // Case 1: Characters match
            if (i < name.length() && name.charAt(i) == typed.charAt(j)) {
                i++;
                j++;
            }

            // Case 2: Long press detected (repeat of previous character)
            else if (j > 0 && typed.charAt(j) == typed.charAt(j - 1)) {
                j++;
            }

            // Case 3: Invalid character
            else {
                return false;
            }
        }

        // All characters in name must be matched
        return i == name.length();
    }
}

ğŸ”¹ Edge Cases to Remember

typed shorter than name â†’ âŒ false

Extra characters must be repeats, not new letters

Order must never change

ğŸ“ One-Line Summary (For Exams)

Use two pointers to traverse both strings, allowing extra characters in typed only if they repeat the previous character, and ensure all characters of name are matched.