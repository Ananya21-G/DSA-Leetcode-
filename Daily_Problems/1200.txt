Problem: Minimum Absolute Difference
Problem Summary

Given an array of distinct integers, find all pairs [a, b] such that:

a < b

b - a is the minimum absolute difference among all pairs

Pairs must be returned in ascending order

ðŸ§  Core Insight (Most Important)

The minimum absolute difference always occurs between adjacent elements in the sorted array.

Why?
Sorting places numerically closest values next to each other. Any non-adjacent pair will have a larger difference.

ðŸ§© Approach Overview

Sort the array

First pass â†’ find the minimum difference between adjacent elements

Second pass â†’ collect all adjacent pairs having that minimum difference

âœ… Final Java Code (Documented)
class Solution {

    public List<List<Integer>> minimumAbsDifference(int[] arr) {

        // Step 1: Sort the array
        // After sorting, the minimum absolute difference
        // can only occur between adjacent elements
        Arrays.sort(arr);

        // Step 2: Find the minimum difference
        int minDiff = Integer.MAX_VALUE;

        for (int i = 1; i < arr.length; i++) {
            // Since array is sorted, arr[i] - arr[i - 1] is non-negative
            minDiff = Math.min(minDiff, arr[i] - arr[i - 1]);
        }

        // Step 3: Collect all pairs with the minimum difference
        List<List<Integer>> result = new ArrayList<>();

        for (int i = 1; i < arr.length; i++) {
            if (arr[i] - arr[i - 1] == minDiff) {
                result.add(Arrays.asList(arr[i - 1], arr[i]));
            }
        }

        return result;
    }
}

ðŸ” Key Details to Remember
Why no Math.abs()?

After sorting:
arr[i] â‰¥ arr[i - 1]
So arr[i] - arr[i - 1] is already the absolute difference.

Why start loop from i = 1?

We compare each element with the previous one

Index 0 has no previous element

Why two passes?

First pass â†’ determine the minimum difference

Second pass â†’ collect all valid pairs
This avoids missing any pairs.

â±ï¸ Complexity Analysis

Time Complexity: O(n log n)

Sorting dominates

Space Complexity: O(1) extra (excluding output list)

ðŸ§  Brain Note (Very Important ðŸ“Œ)

Pattern: Sorting + adjacent comparison
When to use: Minimum / maximum difference problems
Core idea: Closest elements appear next to each other after sorting

ðŸ§ª Example Walkthrough

Input:

[4, 2, 1, 3]


After sorting:

[1, 2, 3, 4]


Differences:

2 - 1 = 1
3 - 2 = 1
4 - 3 = 1


Minimum difference = 1
Output:

[[1,2], [2,3], [3,4]]
